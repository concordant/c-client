class CObject<T> {

  // Concordant object unique id
  private id: CObjectUId

  // Is openned in read only mode
  private readOnly: Boolean

  // The encapsulated CRDT
  private crdt: DeltaCRDT<T>

  // Backup for the necapsulated CRDT (used in case of transaction abort)
  private txnBackup: DeltaCRDT<T>?

  CObject(oid: CObjectUId, crdt: DeltaCRDT<T>, readOnly: Boolean) {
    this.id = oid
    this.crdt = crdt
    this.readOnly = readOnly
    this.txnBackup = null
  }

  package fun txnAbort() {
    this.crdt = this.txnBackup
    this.txnBackup = null
  }

  package fun txnCommit() {
    this.txnBackup = null
  }

  fun update(args) {
    if (Session.currentTransaction == null) throw Exception
    if (this.readOnly) throw Exception
    if (NOT ActiveSession.dirtyObjects.contains(this.id)) {
      ActiveSession.dirtyObjects.put(this.id, this)
      this.txnBackup = this.crdt.copy()
    }
    // Should be integrrated to CRDTs
    ts = ActiveSession.txnEnv.tick()
    this.crdt.update(args, ts)
  }

  fun getter(args): val {
    if (ActiveSession.currentTransaction == null) throw Exception
    return crdt.getter(args)
  }

  fun close() {
    if (NOT ActiveSession.currentTransaction == null) throw Exception
    ActiveSession.cache.remove(this.id)
    ActiveSession.handlers.remove(this.id)
    SERVICE.unsubscribe(this.id)
  }
}
